# Pipeline 排程邏輯詳細說明

本文件詳細描述 `pipeline_executeFullScheduling()` 函式的每個步驟，解釋其資料處理邏輯與分群規則。

---

## 執行流程總覽

```
pipeline_executeFullScheduling()
├── 階段 1: buildFilteredCandidateList()     - 建立候選名單
├── 階段 2: pipeline_loadData()              - 載入所有資料
├── 階段 3: Pipeline 處理（記憶體中連續處理）
│   ├── pipeline_scheduleCommonSubjects()    - 安排共同科目節次
│   ├── pipeline_scheduleSpecializedSubjects() - 安排專業科目節次
│   ├── pipeline_assignRooms()               - 安排試場
│   ├── pipeline_sortStudents()              - 排序學生
│   ├── pipeline_allocateBagIdentifiers()    - 計算大小袋編號
│   ├── pipeline_populateSessionTimes()      - 填入節次時間
│   └── pipeline_updatePopulations()         - 計算各種人數
├── 階段 4: pipeline_saveData()              - 一次性寫回試算表
└── 階段 5: pipeline_generateAllReports()    - 產生所有報表
```

---

## 階段 1：建立候選名單 `buildFilteredCandidateList()`

### 目的
從「註冊組補考名單」篩選出需要補考的學生，建立「排入考程的補考名單」。

### 資料來源
1. **教學組排入考程的科目** (`TEACHING_SELECTION_SHEET`)：決定哪些科目需要補考
2. **註冊組補考名單** (`UNFILTERED_MAKEUP_SHEET`)：所有可能需要補考的學生
3. **開課資料** (`OPEN_COURSE_LOOKUP_SHEET`)：查詢任課教師

### 篩選邏輯
1. 從「教學組排入考程的科目」中找出「要補考」欄位為 `true` 的課程代碼
2. 比對「註冊組補考名單」中的「科目代碼補完」欄位
3. 符合條件的學生寫入「排入考程的補考名單」

### 輸出欄位
每筆學生資料包含 19 個欄位：

| 索引 | 欄位名稱 | 來源/初始值                                 |
| ---- | -------- | ------------------------------------------- |
| 0    | 科別     | 從班級名稱推導（如「機械二甲」→「機械科」） |
| 1    | 年級     | 從班級名稱推導（如「機械二甲」→「2」）      |
| 2    | 班級代碼 | 從班級名稱推導（如「機械二甲」→「301201」） |
| 3    | 班級     | 原始班級名稱（如「機械二甲」）              |
| 4    | 座號     | 原始資料                                    |
| 5    | 學號     | 原始資料                                    |
| 6    | 姓名     | 原始資料                                    |
| 7    | 科目名稱 | 原始資料                                    |
| 8    | 節次     | 初始值 `0`（待分配）                        |
| 9    | 試場     | 初始值 `0`（待分配）                        |
| 10   | 小袋序號 | 空（待計算）                                |
| 11   | 小袋人數 | 空（待計算）                                |
| 12   | 大袋序號 | 空（待計算）                                |
| 13   | 大袋人數 | 空（待計算）                                |
| 14   | 班級人數 | 空（待計算）                                |
| 15   | 時間     | 空（待填入）                                |
| 16   | 電腦     | ☑ 或 ☐                                      |
| 17   | 人工     | ☑ 或 ☐                                      |
| 18   | 任課老師 | 從開課資料查詢                              |

---

## 階段 2：載入資料 `pipeline_loadData()`

### 目的
一次性讀取所有需要的資料，建立 Pipeline 上下文物件。

### 載入的資料

#### 參數配置（來自「參數區」工作表）
| 參數名稱             | 儲存格 | 說明               | 範例值 |
| -------------------- | ------ | ------------------ | ------ |
| `maxSessionCount`    | B5     | 節數上限           | 8      |
| `maxRoomCount`       | B6     | 試場數量           | 20     |
| `maxStudentsPerRoom` | B7     | 每間試場人數上限   | 34     |
| `maxSubjectsPerRoom` | B8     | 試場容納科目上限   | 4      |
| `sessionCapacity`    | B9     | 每節可容納學生人數 | 680    |

#### 科目節次規則（來自「參數區」E2:F22）
預先指定特定共同科目要放在哪一節：

| 科目名稱                           | 指定節次 |
| ---------------------------------- | -------- |
| 物理                               | 1        |
| 國語文                             | 2        |
| 英語文                             | 3        |
| 數學、數學統合、數學演習、應用數學 | 4        |
| 資訊科技                           | 5        |
| 公民與社會                         | 7        |
| 歷史、地理                         | 8        |
| 基礎工程力學、化工裝置             | 2        |

---

## 階段 3-1：安排共同科目節次 `pipeline_scheduleCommonSubjects()`

### 目的
將預先指定節次的共同科目（如國文、英文、數學）分配到指定節次。

### 分群依據
**無分群** - 純粹依照「科目名稱」查表

### 處理邏輯
```
對於每個學生：
    查詢該學生的「科目名稱」是否在 sessionRules 中
    若有對應規則：
        將該學生的「節次」設為規則指定的值
    若無對應規則：
        「節次」維持為 0（交由後續步驟處理）
```

### 範例
| 學生 | 科目名稱             | 處理前節次 | 處理後節次 |
| ---- | -------------------- | ---------- | ---------- |
| 張三 | 國語文               | 0          | 2          |
| 李四 | 數學                 | 0          | 4          |
| 王五 | 電腦輔助機械製圖實習 | 0          | 0（不變）  |

---

## 階段 3-2：安排專業科目節次 `pipeline_scheduleSpecializedSubjects()`

### 目的
將尚未分配節次的學生（專業科目）分配到各節次，確保：
1. 同一「科別+年級」的學生不會在同一節有不同科目（避免考生衝堂）
2. 每節人數不超過容量上限的 90%

### 分群依據
**科別 + 年級 + 科目名稱**

例如：
- `機械科2_電腦輔助機械製圖實習` → 代表所有機械科二年級補考「電腦輔助機械製圖實習」的學生
- `資訊科1_基本電學實習` → 代表所有資訊科一年級補考「基本電學實習」的學生

### 互斥規則（關鍵）
**同一「科別+年級」的學生，在同一節次中只能有一個科目**

這是為了避免考生衝堂。例如：
- 若「機械科2年級」的「電腦輔助機械製圖實習」已分配到第 1 節
- 則「機械科2年級」的「機械製造」就**不能**分配到第 1 節

### 處理邏輯
```
步驟 1: 統計每個「科別+年級+科目」組合的人數
        只統計節次 = 0 的學生（尚未分配）

步驟 2: 依人數從多到少排序
        優先處理大群組，確保大群組能找到合適的節次

步驟 3: 依序分配到各節次
        for 節次 = 1 to 最大節數:
            for 每個「科別+年級+科目」組合（按人數排序）:
                檢查互斥規則：
                    若該節次已有相同「科別+年級」的其他科目 → 跳過
                檢查容量：
                    若加入後超過 sessionCapacity × 90% → 跳過
                符合條件：
                    將該組合的所有學生分配到此節次
                    記錄此「科別+年級」已在此節次使用
```

### 範例
假設有以下學生（節次皆為 0）：

| 科別+年級+科目       | 人數 |
| -------------------- | ---- |
| 機械科2_機械製造     | 25   |
| 機械科2_電腦輔助製圖 | 20   |
| 資訊科2_程式設計     | 18   |
| 資訊科2_網頁設計     | 15   |

分配過程：
1. 第 1 節：放入「機械科2_機械製造」(25人)、「資訊科2_程式設計」(18人)
   - ✅ 機械科2 和 資訊科2 互不衝突
2. 第 2 節：放入「機械科2_電腦輔助製圖」(20人)、「資訊科2_網頁設計」(15人)
   - ✅ 這些學生跟第 1 節的學生不同科目

最終結果：
- 機械科2年級的學生，第 1 節考「機械製造」，第 2 節考「電腦輔助製圖」
- 資訊科2年級的學生，第 1 節考「程式設計」，第 2 節考「網頁設計」

---

## 階段 3-3：安排試場 `pipeline_assignRooms()`

### 目的
將每個節次的學生分配到試場，確保：
1. 每間試場人數不超過上限（如 34 人）
2. 每間試場科目數不超過上限（如 4 科）

### 分群依據
**班級 + 科目名稱**

例如：
- `機械二甲電腦輔助機械製圖實習` → 機械二甲班補考此科目的所有學生
- `資訊一乙基本電學實習` → 資訊一乙班補考此科目的所有學生

### 為什麼用「班級+科目」而非「科別+年級+科目」？
因為試卷是按「班級」和「科目」收發的：
- 同班同科的考卷會放在同一個小袋
- 便於監考老師分發和收回考卷

### 處理邏輯
```
for 節次 = 1 to 最大節數:
    取得該節次所有學生
    
    統計每個「班級+科目」組合的人數
    依人數從多到少排序
    
    for 試場 = 1 to 最大試場數:
        for 每個「班級+科目」組合:
            若該組合已分配 → 跳過
            若加入後人數超過上限 → 跳過
            若加入後科目數超過上限 → 跳過
            
            符合條件：
                將該組合所有學生分配到此試場
```

### 範例
假設第 1 節有以下學生，每間試場上限 34 人、4 科：

| 班級+科目         | 人數 |
| ----------------- | ---- |
| 機械二甲_機械製造 | 15   |
| 機械二乙_機械製造 | 12   |
| 資訊二甲_程式設計 | 10   |
| 資訊二乙_程式設計 | 8    |
| 電子二甲_電子學   | 6    |

分配結果：
- 試場 1：機械二甲_機械製造(15) + 機械二乙_機械製造(12) = 27人、2科
- 試場 2：資訊二甲_程式設計(10) + 資訊二乙_程式設計(8) + 電子二甲_電子學(6) = 24人、3科

---

## 階段 3-4：排序學生 `pipeline_sortStudents()`

### 目的
將學生按特定順序排序，為後續計算大小袋編號做準備。

### 排序優先順序
1. **節次**（升冪）
2. **試場**（升冪）
3. **科別**（中文排序）
4. **年級**（中文排序）
5. **座號**（數字升冪）
6. **科目名稱**（中文排序）

### 為什麼需要這個排序？
大小袋編號必須連續分配，且同一試場內的學生要連在一起。

---

## 階段 3-5：計算大小袋編號 `pipeline_allocateBagIdentifiers()`

### 目的
為每位學生分配小袋序號和大袋序號。

### 概念定義
- **小袋**：同一試場內、同一班級、同一科目的考卷放一袋
  - 分群依據：**節次 + 試場 + 班級 + 科目名稱**
- **大袋**：同一試場的所有小袋放一袋
  - 分群依據：**節次 + 試場**

### 處理邏輯
```
smallBagCounter = 1
bigBagCounter = 1
lastSession = null
lastRoom = null
smallBagMapping = {}  // 記錄每個「班級+科目」對應的小袋編號

for 每個學生（已按節次、試場排序）:
    若 節次 或 試場 改變:
        bigBagCounter++        // 新大袋
        smallBagMapping = {}   // 重置小袋對映
        
    classSubjectKey = 班級 + 科目名稱
    
    若 smallBagMapping[classSubjectKey] 不存在:
        smallBagMapping[classSubjectKey] = smallBagCounter++  // 新小袋
    
    學生.小袋序號 = smallBagMapping[classSubjectKey]
    學生.大袋序號 = bigBagCounter
```

### 範例
| 節次 | 試場 | 班級     | 科目         | 小袋序號 | 大袋序號 |
| ---- | ---- | -------- | ------------ | -------- | -------- |
| 1    | 1    | 機械二甲 | 機械製造     | 1        | 1        |
| 1    | 1    | 機械二甲 | 機械製造     | 1        | 1        |
| 1    | 1    | 機械二乙 | 機械製造     | 2        | 1        |
| 1    | 2    | 資訊二甲 | 程式設計     | 3        | 2        |
| 2    | 1    | 機械二甲 | 電腦輔助製圖 | 4        | 3        |

---

## 階段 3-6：填入節次時間 `pipeline_populateSessionTimes()`

### 目的
根據節次查表填入考試時間。

### 資料來源
「節次時間表」工作表：

| 節次 | 時間        |
| ---- | ----------- |
| 1    | 08:10-09:00 |
| 2    | 09:10-10:00 |
| 3    | 10:10-11:00 |
| 4    | 11:10-12:00 |
| 5    | 13:20-14:10 |
| ...  | ...         |

### 處理邏輯
```
for 每個學生:
    學生.時間 = 時間表[學生.節次]
```

---

## 階段 3-7：計算各種人數 `pipeline_updatePopulations()`

### 目的
計算三種人數統計值。

### 計算的人數

#### 1. 小袋人數（`smallBagPopulation`）
- **定義**：同節次、同試場、同班級、同科目的學生人數
- **分群依據**：節次 + 試場 + 班級 + 科目名稱
- **用途**：A 表「班級人數」欄、小袋封面印刷

#### 2. 大袋人數（`bigBagPopulation`）
- **定義**：同節次、同試場的學生總人數
- **分群依據**：節次 + 試場
- **用途**：大袋封面印刷

#### 3. 班級人數（`classPopulation`）
- **定義**：該班級在整場考試中的補考總人數
- **分群依據**：班級
- **用途**：統計用途

### 處理邏輯
```
// 計算班級總人數
classPopulationMap = {}
for 每個學生:
    classPopulationMap[學生.班級]++

// 計算小袋人數和大袋人數
roomClassSubjectMap = {}  // "節次_試場_班級_科目" -> 人數
roomPopulationMap = {}    // "節次_試場" -> 人數

for 每個學生:
    roomKey = 節次 + "_" + 試場
    classSubjectKey = roomKey + "_" + 班級 + 科目
    roomClassSubjectMap[classSubjectKey]++
    roomPopulationMap[roomKey]++

// 更新學生資料
for 每個學生:
    學生.小袋人數 = roomClassSubjectMap[對應key]
    學生.大袋人數 = roomPopulationMap[對應key]
    學生.班級人數 = classPopulationMap[學生.班級]
```

---

## 階段 4：寫回試算表 `pipeline_saveData()`

將記憶體中的學生資料一次性寫回「排入考程的補考名單」工作表。

---

## 階段 5：產生報表 `pipeline_generateAllReports()`

### 產生的報表

1. **公告版補考場次** (`pipeline_createExamBulletinSheet`)
   - 按班級座號排序
   - 姓名遮罩處理（如「王小明」→「王〇明」）

2. **試場紀錄表 A 表** (`pipeline_createProctorRecordSheet`)
   - 按節次試場排序
   - 供監考老師使用

3. **小袋封面套印用資料** (`pipeline_composeSmallBagDataset`)
   - 每個小袋一列
   - 包含節次、時間、試場、班級、科目、任課老師等

4. **大袋封面套印用資料** (`pipeline_composeBigBagDataset`)
   - 每個大袋一列
   - 包含節次、試場、補考日期、監考教師等

---

## 附錄：分群依據總整理

| 步驟             | 分群依據                      | 用途                 |
| ---------------- | ----------------------------- | -------------------- |
| 安排共同科目節次 | 科目名稱                      | 查表決定節次         |
| 安排專業科目節次 | **科別 + 年級 + 科目名稱**    | 確保同科別年級不衝堂 |
| 安排試場         | **班級 + 科目名稱**           | 便於考卷分發收回     |
| 計算小袋編號     | 節次 + 試場 + 班級 + 科目名稱 | 小袋分裝             |
| 計算大袋編號     | 節次 + 試場                   | 大袋分裝             |
| 小袋人數         | 節次 + 試場 + 班級 + 科目名稱 | 統計                 |
| 大袋人數         | 節次 + 試場                   | 統計                 |
| 班級人數         | 班級                          | 統計                 |

---

## 附錄：關鍵限制條件

| 限制           | 參數                  | 預設值 | 檢查時機         |
| -------------- | --------------------- | ------ | ---------------- |
| 每節容量       | sessionCapacity × 90% | 612 人 | 安排專業科目節次 |
| 每間試場人數   | maxStudentsPerRoom    | 34 人  | 安排試場         |
| 每間試場科目數 | maxSubjectsPerRoom    | 4 科   | 安排試場         |
| 最大節數       | maxSessionCount       | 8 節   | 安排專業科目節次 |
| 最大試場數     | maxRoomCount          | 20 間  | 安排試場         |
